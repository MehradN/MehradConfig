package ir.mehradn.mehradconfig;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import ir.mehradn.mehradconfig.entry.ConfigEntry;
import net.fabricmc.loader.api.FabricLoader;
import net.minecraft.network.FriendlyByteBuf;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.BitSet;
import java.util.List;

/**
 * MehradConfig is an abstract class for creating your own configs.
 *
 * @see <a href="https://github.com/MehradN/MehradConfig"><code>ExampleConfig.json</code></a>
 */
public abstract class MehradConfig {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    /**
     * The modId of the mod. It's assumed to be the same modId that provides the translations.
     */
    public final String modId;
    /**
     * The name of the config, used in translations and the name of the config file.
     */
    public final String name;

    /**
     * The name of the config will be same as the {@code modId}. The config will be saved in {@code {modId}.json}.
     *
     * @param modId the modId of the mod. Should be the same modId that provides the translations.
     */
    protected MehradConfig(String modId) {
        this(modId, modId);
    }

    /**
     * The config will be saved in {@code {name}.json}.
     *
     * @param modId the modId of the mod. Should be the same modId that provides the translations.
     * @param name  the name of the config
     */
    protected MehradConfig(String modId, String name) {
        this.modId = modId;
        this.name = name;
    }

    /**
     * Must return the full list of all of the config entries that this config contains. The {@link ConfigEntry#getName name of the entires} should
     * be unique and not repeat. The returned list must always return the exact same list for per instance, otherwise, unexpected behaviours might
     * happen. The returned list should preferably be immutable.
     * <p>
     * This method is often used for iterating through all the entries, in places like the gui or reading/writing to json/buffers.
     *
     * @return A list of the config entries that this config contains.
     */
    public abstract List<ConfigEntry<?>> getEntries();

    /**
     * Must create a new instance of the same class and return it. The created instance must be the same regardless of the context of this instance.
     * (In other words, this method must be implemented like a static method)
     * <p>
     * This method is often used with methods {@link #copyTo} or {@link #load} to create copies of this config.
     *
     * @return a new instance of the same class
     * @see #copyTo
     * @see #fromJson
     * @see #readFromBuf
     * @see #load
     */
    public abstract MehradConfig createNewInstance();

    /**
     * Resets all of the config entries to their default values.
     *
     * @see ConfigEntry#reset
     */
    public void reset() {
        for (ConfigEntry<?> entry : getEntries())
            entry.reset();
    }

    /**
     * @return if all of the config entries are the same as their default values
     * @see ConfigEntry#isDefault
     */
    public boolean isAllDefault() {
        for (ConfigEntry<?> entry : getEntries())
            if (!entry.isDefault())
                return false;
        return true;
    }

    /**
     * Copies the values of this config's entries, to the given config's entries. This method is mostly intended to be used with
     * configs of the same class. But it does also work for configs of different type if their design are compatible. All that matters is that the
     * order of the entries and the type of the entries' value to be same for both configs.
     *
     * @param config the config to copy the values to
     * @see ConfigEntry#copyTo
     * @see ConfigEntry#entryTypeInfo
     * @see #getEntries
     */
    public void copyTo(MehradConfig config) {
        pairEntries(getEntries(), config.getEntries(), ConfigEntry::copyTo);
    }

    /**
     * @return a json object containing the values of this config's entries
     * @see ConfigEntry#toJson
     */
    public JsonObject toJson() {
        JsonObject json = new JsonObject();
        for (ConfigEntry<?> entry : getEntries())
            if (entry.shouldWrite())
                json.add(entry.getName(), entry.toJson());
        return json;
    }

    /**
     * Sets the value of the entries from a json object. It's safe to assume the json was generated by {@link #toJson}.
     *
     * @param json a json object containing the values of this config's entries
     * @see ConfigEntry#fromJson
     */
    public void fromJson(JsonObject json) {
        for (ConfigEntry<?> entry : this.getEntries()) {
            String name = entry.getName();
            if (json.has(name))
                entry.fromJson(json.get(name));
            else
                entry.reset();
        }
    }

    /**
     * Writes the values of this config's entries to the given packet byte buffer.
     *
     * @param buf the buffer to write the values to
     * @see ConfigEntry#writeToBuf
     */
    public void writeToBuf(FriendlyByteBuf buf) {
        List<ConfigEntry<?>> entries = getEntries();
        int size = entries.size();
        BitSet bs = new BitSet(size);

        for (int i = 0; i < size; i++)
            bs.set(i, entries.get(i).shouldWrite());
        buf.writeBitSet(bs);

        for (int i = 0; i < size; i++)
            if (bs.get(i))
                entries.get(i).writeToBuf(buf);
    }

    /**
     * Reads and sets the values of this config's entries from the given packet byte buffer.
     *
     * @param buf the buffer to read the values from
     * @see ConfigEntry#readFromBuf
     */
    public void readFromBuf(FriendlyByteBuf buf) {
        List<ConfigEntry<?>> entries = getEntries();
        int size = entries.size();
        BitSet bs = buf.readBitSet();

        for (int i = 0; i < size; i++) {
            if (i < bs.size() && bs.get(i))
                entries.get(i).readFromBuf(buf);
            else
                entries.get(i).reset();
        }
    }

    /**
     * Writes the values of this config's entries to a json file in the config folder. The name of the file is determined by the file name passed
     * in the constructor.
     *
     * @throws IOException if any of the IO operations fail
     */
    public void save() throws IOException {
        Path configDir = FabricLoader.getInstance().getConfigDir();
        Files.createDirectories(configDir);

        Path configFile = configDir.resolve(this.name + ".json");
        JsonObject json = toJson();
        try (FileWriter writer = new FileWriter(configFile.toFile())) {
            GSON.toJson(json, writer);
        }
    }

    /**
     * Reads and sets the values of this config's entries to a json file in the config folder. The name of the file is determined by the file name
     * passed in the constructor.
     *
     * @throws IOException if any of the IO operations fail
     */
    public void load() throws IOException {
        Path configFile = FabricLoader.getInstance().getConfigDir().resolve(this.name + ".json");
        try (FileReader reader = new FileReader(configFile.toFile())) {
            JsonObject json = GSON.fromJson(reader, JsonObject.class);
            fromJson(json);
        }
    }

    private void pairEntries(List<ConfigEntry<?>> entries1, List<ConfigEntry<?>> entries2, SameTypeEntryAction<?> action) {
        int size = Math.min(entries1.size(), entries2.size());
        for (int i = 0; i < size; i++)
            sameTypeEntry(entries1.get(i), entries2.get(i), action);
    }

    @SuppressWarnings("unchecked")
    private <T> void sameTypeEntry(ConfigEntry<?> entry1, ConfigEntry<?> entry2, SameTypeEntryAction<T> action) {
        if (!entry1.entryTypeInfo().typeClass().equals(entry2.entryTypeInfo().getClass()))
            throw new IllegalArgumentException("Mismatching entry types, Invalid argument type!");
        action.run((ConfigEntry<T>)entry1, (ConfigEntry<T>)entry2);
    }

    @FunctionalInterface
    private interface SameTypeEntryAction <T> {
        void run(ConfigEntry<T> entry1, ConfigEntry<T> entry2);
    }
}
